"""Email delivery for scheduled skill reports.

Supports two delivery tiers with automatic failover:
  Tier 1: Mail.app AppleScript -- uses the already-configured Exchange account,
          zero credentials needed.
  Tier 2: SMTP relay -- any standard SMTP server (Brevo free tier, etc.).

The ``delivery_method`` config (auto | mail_app | smtp) controls which tiers
are attempted.  Default is ``auto`` (try Mail.app, fall back to SMTP).
"""

from __future__ import annotations

import logging
import os
import smtplib
import subprocess
import sys
import tempfile
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from pathlib import Path
from typing import Any

import yaml

sys.path.insert(0, str(Path(__file__).resolve().parent.parent.parent))

logger = logging.getLogger("memoryos.agents.email")

REPO_DIR = Path(__file__).resolve().parent.parent.parent
CONFIG_PATH = REPO_DIR / "config" / "config.yaml"

_EMAIL_CSS = """
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
         max-width: 700px; margin: 0 auto; padding: 20px; color: #1a1a2e;
         line-height: 1.6; background: #fafafa; }
  h1 { border-bottom: 2px solid #6c7cff; padding-bottom: 8px; color: #1a1a2e; }
  h2 { color: #2d2d44; margin-top: 24px; }
  h3 { color: #4a4a6a; }
  table { border-collapse: collapse; width: 100%; margin: 12px 0; }
  th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; font-size: 14px; }
  th { background: #f0f0f8; font-weight: 600; }
  tr:nth-child(even) { background: #f8f8fc; }
  code { background: #eef; padding: 2px 6px; border-radius: 4px; font-size: 13px; }
  a { color: #6c7cff; }
  blockquote { border-left: 3px solid #6c7cff; margin: 12px 0; padding: 8px 16px;
               background: #f0f0f8; }
  .footer { margin-top: 32px; padding-top: 16px; border-top: 1px solid #ddd;
            font-size: 12px; color: #888; }
</style>
"""


# ── Config ────────────────────────────────────────────────────────────────────

def _load_email_config() -> dict[str, Any]:
    """Load email settings from config.yaml and environment variables."""
    cfg: dict[str, Any] = {
        "enabled": False,
        "delivery_method": os.environ.get("MEMORYOS_DELIVERY_METHOD", "auto"),
        "from": os.environ.get("MEMORYOS_EMAIL_FROM", ""),
        "to": os.environ.get("MEMORYOS_EMAIL_TO", ""),
        "smtp_host": os.environ.get("MEMORYOS_SMTP_HOST", "smtp.office365.com"),
        "smtp_port": int(os.environ.get("MEMORYOS_SMTP_PORT", "587")),
        "smtp_user": os.environ.get("MEMORYOS_SMTP_USER", ""),
        "smtp_password": os.environ.get("MEMORYOS_SMTP_PASSWORD", ""),
    }

    if CONFIG_PATH.is_file():
        try:
            raw = yaml.safe_load(CONFIG_PATH.read_text(encoding="utf-8")) or {}
            email_cfg = raw.get("agents", {}).get("email", {})
            for key in (
                "enabled", "delivery_method",
                "from", "to",
                "smtp_host", "smtp_port", "smtp_user",
            ):
                if key in email_cfg and email_cfg[key]:
                    cfg[key] = email_cfg[key]
        except Exception as exc:
            logger.warning("Failed to load email config: %s", exc)

    if not cfg["smtp_user"] and cfg["from"]:
        cfg["smtp_user"] = cfg["from"]

    return cfg


# ── Markdown -> HTML ──────────────────────────────────────────────────────────

def _md_to_html(markdown_text: str) -> str:
    """Convert markdown to HTML with styling."""
    try:
        import markdown as md
        html_body = md.markdown(
            markdown_text,
            extensions=["tables", "fenced_code", "nl2br"],
        )
    except ImportError:
        html_body = f"<pre>{markdown_text}</pre>"

    return (
        f"<html><head>{_EMAIL_CSS}</head><body>{html_body}"
        f'<div class="footer">Generated by MemoryOS Agent Skills</div>'
        f"</body></html>"
    )


# ── Tier 1: Mail.app AppleScript ─────────────────────────────────────────────

def _escape_applescript(s: str) -> str:
    """Escape a string for safe embedding in an AppleScript double-quoted literal."""
    return s.replace("\\", "\\\\").replace('"', '\\"')


def _send_via_mail_app(
    to_addr: str,
    subject: str,
    html_body: str,
    plain_body: str = "",
    attachment_path: str | None = None,
    *,
    timeout: int = 45,
) -> dict[str, Any]:
    """Send an email via Mail.app's AppleScript interface.

    Uses the already-configured Exchange account -- no SMTP credentials needed.

    Mail.app's ``html content`` property is broken with Exchange accounts.
    We send a plain-text body via ``content:`` and optionally attach an HTML
    file so the recipient can open the full rich report in a browser.
    """
    body_text = plain_body or html_body
    with tempfile.NamedTemporaryFile(
        mode="w", suffix=".txt", delete=False, encoding="utf-8",
    ) as f:
        f.write(body_text)
        body_file = f.name

    safe_subject = _escape_applescript(subject)
    safe_to = _escape_applescript(to_addr)

    attachment_line = ""
    if attachment_path:
        attachment_line = (
            f'\n    make new attachment with properties '
            f'{{file name:POSIX file "{attachment_path}"}} at after the last paragraph'
        )

    script = f'''
set bodyFile to POSIX file "{body_file}"
set bodyContent to read bodyFile as «class utf8»

tell application "Mail"
    set newMsg to make new outgoing message with properties {{subject:"{safe_subject}", content:bodyContent, visible:false}}
    tell newMsg
        make new to recipient at end of to recipients with properties {{address:"{safe_to}"}}{attachment_line}
    end tell
    send newMsg
end tell
'''

    try:
        result = subprocess.run(
            ["osascript", "-e", script],
            capture_output=True, text=True, timeout=timeout,
        )
    except subprocess.TimeoutExpired:
        logger.warning("Mail.app send timed out after %ds", timeout)
        return {"ok": False, "detail": f"Mail.app AppleScript timed out ({timeout}s)"}
    finally:
        Path(body_file).unlink(missing_ok=True)

    if result.returncode != 0:
        detail = result.stderr.strip()[:300] or "unknown error"
        logger.warning("Mail.app send failed: %s", detail)
        return {"ok": False, "detail": f"Mail.app error: {detail}"}

    logger.info("Email sent via Mail.app: '%s' -> %s", subject, to_addr)
    return {"ok": True, "detail": f"Sent via Mail.app to {to_addr}"}


# ── Tier 2: SMTP relay ───────────────────────────────────────────────────────

def _send_via_smtp(
    to_addr: str,
    sender: str,
    subject: str,
    markdown_body: str,
    html_body: str,
    cfg: dict[str, Any],
) -> dict[str, Any]:
    """Send an email via SMTP (Brevo, O365, or any relay)."""
    smtp_host = cfg["smtp_host"]
    smtp_port = cfg["smtp_port"]
    smtp_user = cfg["smtp_user"]
    smtp_pass = cfg["smtp_password"]

    if not smtp_pass:
        return {
            "ok": False,
            "detail": "SMTP password not set (MEMORYOS_SMTP_PASSWORD)",
        }

    msg = MIMEMultipart("alternative")
    msg["Subject"] = subject
    msg["From"] = sender
    msg["To"] = to_addr
    msg["Reply-To"] = to_addr

    msg.attach(MIMEText(markdown_body, "plain", "utf-8"))
    msg.attach(MIMEText(html_body, "html", "utf-8"))

    md_att = MIMEText(markdown_body, "plain", "utf-8")
    md_att.add_header("Content-Disposition", "attachment", filename="report.md")
    msg.attach(md_att)

    try:
        with smtplib.SMTP(smtp_host, smtp_port, timeout=30) as server:
            server.ehlo()
            server.starttls()
            server.ehlo()
            server.login(smtp_user, smtp_pass)
            server.sendmail(sender, [to_addr], msg.as_string())
        logger.info("Email sent via SMTP: '%s' -> %s", subject, to_addr)
        return {"ok": True, "detail": f"Sent via SMTP to {to_addr}"}
    except Exception as exc:
        logger.error("SMTP send failed: %s", exc)
        return {"ok": False, "detail": str(exc)[:300]}


# ── Public API ────────────────────────────────────────────────────────────────

def send_report(
    subject: str,
    markdown_body: str,
    to: str | None = None,
    from_addr: str | None = None,
    html_override: str | None = None,
) -> dict[str, Any]:
    """Send a markdown report using the configured delivery method with failover.

    Delivery methods (``agents.email.delivery_method`` in config):
      - ``auto``:     try Mail.app first, fall back to SMTP  (default)
      - ``mail_app``: only use Mail.app AppleScript
      - ``smtp``:     only use SMTP relay

    When *html_override* is provided, it is used directly instead of
    converting markdown to HTML (used for rich skill-report emails).

    Returns dict with keys: ok (bool), detail (str).
    """
    cfg = _load_email_config()

    to_addr = to or cfg["to"]
    sender = from_addr or cfg["from"]
    method = cfg.get("delivery_method", "auto")

    if not to_addr or not sender:
        return {"ok": False, "detail": "Email from/to not configured"}

    html_body = html_override if html_override else _md_to_html(markdown_body)

    # ── Tier 1: Mail.app ──
    # Mail.app's html content property is broken with Exchange.
    # Send plain-text body + attach the rich HTML for browser viewing.
    if method in ("auto", "mail_app"):
        html_attachment = None
        if html_override:
            att = tempfile.NamedTemporaryFile(
                mode="w", suffix=".html", delete=False, encoding="utf-8",
                prefix="MemoryOS_Report_",
            )
            att.write(html_override)
            att.close()
            html_attachment = att.name

        brief = markdown_body[:3000]
        if len(markdown_body) > 3000:
            brief += "\n\n[... open the attached HTML report for the full version ...]"
        if html_attachment:
            brief = (
                "Open the attached HTML file in your browser for the full "
                "rich-formatted report with images and interactive charts.\n\n"
                "---\n\n" + brief
            )

        result = _send_via_mail_app(
            to_addr, subject, html_body,
            plain_body=brief,
            attachment_path=html_attachment,
        )
        if html_attachment:
            Path(html_attachment).unlink(missing_ok=True)
        if result["ok"]:
            return result
        tier1_detail = result["detail"]
        if method == "mail_app":
            return result
        logger.info("Mail.app delivery failed, falling back to SMTP: %s", tier1_detail)

    # ── Tier 2: SMTP ──
    if method in ("auto", "smtp"):
        result = _send_via_smtp(
            to_addr, sender, subject, markdown_body, html_body, cfg,
        )
        if result["ok"]:
            return result
        tier2_detail = result["detail"]

        if method == "auto":
            return {
                "ok": False,
                "detail": f"All delivery methods failed. "
                          f"Mail.app: {tier1_detail}; SMTP: {tier2_detail}",
            }
        return result

    return {"ok": False, "detail": f"Unknown delivery_method: {method}"}


def send_test_email() -> dict[str, Any]:
    """Send a test email to verify the delivery pipeline."""
    return send_report(
        subject="[MemOS] Test Email -- Delivery Pipeline Verified",
        markdown_body=(
            "# MemoryOS Email Test\n\n"
            "If you received this, your email delivery pipeline is working.\n\n"
            "Scheduled skill reports will be delivered to this address."
        ),
    )
